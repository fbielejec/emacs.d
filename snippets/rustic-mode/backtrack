# -*- mode: snippet -*-
# name: backtrack
# key: <backtrack
# --

    fn backtrack(
        path: &mut Vec<i32>,
        start: usize,
        nums: &[i32],
        used: &mut HashSet<i32>,
        answer: &mut Vec<Vec<i32>>,
    ) {
        if path.len() == nums.len() {
            answer.push(path.clone());
            return;
        }

        // generates permutations
        for i in start..nums.len() {
            let num = nums[i];
            if !used.contains(&num) {
                path.push(num);
                used.insert(num);

                // use the same (start == i) or a higher (start == i+1) start index in the recursive to skip the permutations
                // combinations are generated in a non-decreasing order.
                backtrack(path, start, nums, used, answer);

                path.pop();
                used.remove(&num);
            }
        }
    }
